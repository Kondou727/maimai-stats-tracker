// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: scores.sql

package scoresdb

import (
	"context"
)

const createScore = `-- name: CreateScore :one
INSERT INTO scores (song_name, chart_type, difficulty, achievement, fc_ap, sync, dx_star, dx_percent)
VALUES (
    ?, ?, ?, ?, ?, ?, ?, ?
)
ON CONFLICT(song_name, chart_type, difficulty) DO UPDATE SET
    achievement = excluded.achievement,
    fc_ap = excluded.fc_ap,
    sync = excluded.sync,
    dx_star = excluded.dx_star,
    dx_percent = excluded.dx_percent

RETURNING song_name, chart_type, difficulty, achievement, fc_ap, sync, dx_star, dx_percent
`

type CreateScoreParams struct {
	SongName    string
	ChartType   string
	Difficulty  string
	Achievement int64
	FcAp        interface{}
	Sync        interface{}
	DxStar      int64
	DxPercent   int64
}

func (q *Queries) CreateScore(ctx context.Context, arg CreateScoreParams) (Score, error) {
	row := q.db.QueryRowContext(ctx, createScore,
		arg.SongName,
		arg.ChartType,
		arg.Difficulty,
		arg.Achievement,
		arg.FcAp,
		arg.Sync,
		arg.DxStar,
		arg.DxPercent,
	)
	var i Score
	err := row.Scan(
		&i.SongName,
		&i.ChartType,
		&i.Difficulty,
		&i.Achievement,
		&i.FcAp,
		&i.Sync,
		&i.DxStar,
		&i.DxPercent,
	)
	return i, err
}
